{% extends "base.html" %}
{% load static %}

{% block content %}
<!-- mediapipe install -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils_3d/control_utils_3d.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>

    <video id="video" style="display:none" autoplay playsinline></video>
    <canvas class="output_canvas" width="360" height="680"><a></a></canvas>
    <div class="landmark-grid-container" style="display:none"></div>


{% endblock %}

{% block script %}

<script type='text/javascript'>
    const userMedia = navigator.mediaDevices.getUserMedia({
        audio: false,
        video: {
            width: 360,
            height: 680,
            facingMode: 'environment'
        }
    });
     
    userMedia.then(function (stream) {
        const videoEl = document.getElementById('video');
     
        const videoTracks = stream.getVideoTracks()[0];
        console.log('카메라 이름 : ' + videoTracks.label);
     
        videoEl.srcObject = stream;
     
    }).catch(function (error) {
        console.error(error.message);
    });


</script>
<script type="module">
    const canvasElement = document.getElementsByClassName('output_canvas')[0]; // 비디오 출력을 위한 캔버스

    const canvasCtx = canvasElement.getContext('2d'); // 2d 형태 캔버스 만들기 (그래프를 그려주는 것)
    const landmarkContainer = document.getElementsByClassName('landmark-grid-container')[0]; // 3d 좌표를 만들기 위한 container
    const grid = new LandmarkGrid(landmarkContainer);  // 3d 좌표에서 Value 값 받아오기
    

    // Canvas에 나오는 선 효과 주기
    function onResults(results) {
        
      if (!results.poseLandmarks) {
        grid.updateLandmarks([]);
        return;
      }
    
      //console.log(grid);
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.segmentationMask, 0, 0,
                          canvasElement.width, canvasElement.height);

      // Only overwrite existing pixels.
      canvasCtx.globalCompositeOperation = 'source-in';
      canvasCtx.fillStyle = 'transparent'; //transparent 투명 상태로 지정
      canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
    

      // Only overwrite missing pixels.
      canvasCtx.globalCompositeOperation = 'destination-atop';
      canvasCtx.drawImage(
          results.image, 0, 0, canvasElement.width, canvasElement.height);
    
      canvasCtx.globalCompositeOperation = 'source-over';
      drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
                     {color: '#00FF00', lineWidth: 4});
      drawLandmarks(canvasCtx, results.poseLandmarks,
                    {color: '#FF0000', lineWidth: 2});
      canvasCtx.restore();
    
      // javascript에서 가져온 값을 stream 형태로 지속적으로 받아온다.
      console.log(grid.landmarks[11]);
        
    
      grid.updateLandmarks(results.poseWorldLandmarks);
    }
    
    // 모델을 가져온다
    const pose = new Pose({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
      }});

    // Pose의 옵션 값 설정
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: true,
      smoothSegmentation: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    pose.onResults(onResults);
    console.log(pose);
    
    const videoEl = document.getElementById('video');
    // 카메라 실행 코드
    const camera = new Camera(videoEl, {
        onFrame: async () => {
        await pose.send({image: videoEl});
        },
        width: 360,
        height: 680
    });
    
    camera.start();
</script>
{% endblock %}
