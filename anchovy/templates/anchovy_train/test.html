{% extends "base.html" %}
{% load static %}

{% block content %}
<video id="video" style="display:none" autoplay playsinline></video> 
<div id="canvas_style">
    <canvas class="output_canvas"></canvas> <!--화면 크기 변경 // 화면 크기에 맞게 변경 화면이 줄어든다 (찌글어짐).-->
</div>
<div class="landmark-grid-container" style="display:none"></div>


{% endblock %}

{% block script %}

<script type='text/javascript'>

  var dh = window.innerHeight;
  var dw = window.innerWidth;

  const canvasElement = document.getElementsByClassName('output_canvas')[0]; // 비디오 출력을 위한 캔버스
  canvasElement.width = dw;
  canvasElement.height = dh;

    const userMedia = navigator.mediaDevices.getUserMedia({
        audio: false,
        video: {
          // 해상도 설정  // 변경 시 그에 맞게 픽셀 수 크기가 작거나 커진다
          // (크기가 커질 경우 픽셀 크기가 작아져서 화면이 작게 보이고)  // 기존에 표현하지 못했던 부분도 명확히 표현
          // (크기가 작아지는 경우 픽셀 크기가 커져서 화면이 크기 보인다) // 기존에 표현되었던 부분이 뭉게져서 표현되기 때문에 잘린것 처럼 보이게 됨
            width: 640,
            height: 360,
            facingMode: 'environment'
        }
    });
     
    userMedia.then(function (stream) {
        const videoEl = document.getElementById('video');
     
        const videoTracks = stream.getVideoTracks()[0];
        console.log('카메라 이름 : ' + videoTracks.label);
     
        videoEl.srcObject = stream;
     
    }).catch(function (error) {
        console.error(error.message);
    });


</script>
{% comment %} <script type="module">
    const canvasElement = document.getElementsByClassName('output_canvas')[0]; // 비디오 출력을 위한 캔버스

    const canvasCtx = canvasElement.getContext('2d'); // 2d 형태 캔버스 만들기 (그래프를 그려주는 것)
    const landmarkContainer = document.getElementsByClassName('landmark-grid-container')[0]; // 3d 좌표를 만들기 위한 container
    const grid = new LandmarkGrid(landmarkContainer);  // 3d 좌표에서 Value 값 받아오기
    

    // Canvas에 나오는 선 효과 주기
    function onResults(results) {
        
      if (!results.poseLandmarks) {
        grid.updateLandmarks([]);
        return;
      }
    
      //console.log(grid);
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.segmentationMask, 0, 0,
                          canvasElement.width, canvasElement.height);

      // Only overwrite existing pixels.
      canvasCtx.globalCompositeOperation = 'source-in';
      canvasCtx.fillStyle = 'transparent'; //transparent 투명 상태로 지정
      canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
    

      // Only overwrite missing pixels.
      canvasCtx.globalCompositeOperation = 'destination-atop';
      canvasCtx.drawImage(
          results.image, 0, 0, canvasElement.width, canvasElement.height);
    
      canvasCtx.globalCompositeOperation = 'source-over';
      drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
                     {color: '#FF0000', lineWidth: 4});
      drawLandmarks(canvasCtx, results.poseLandmarks,
                    {color: '#00FFFF', lineWidth: 2});
      canvasCtx.restore();
    
      // javascript에서 가져온 값을 stream 형태로 지속적으로 받아온다.
      console.log(grid.landmarks[11]);
      $.ajax({
        type: "POST",
        url: "{% url 'angle_cal' %}",
        data: {'landmarks':grid.landmarks[11]},
        dataType:'json',
        success: function (data) {
          // 쿠폰 사용에 성공 했으면
          console.log('앵글 성공')
        },
        error: function (data) { //데이터 받아오기 실패
          console.log('앵글 연결 실패');
        }
    });
        
    
      grid.updateLandmarks(results.poseWorldLandmarks);
    }
    
    // 모델을 가져온다
    const pose = new Pose({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
      }});

    // Pose의 옵션 값 설정
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: true,
      smoothSegmentation: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    pose.onResults(onResults);
    console.log(pose);
    
    const videoEl = document.getElementById('video');
    // 카메라 실행 코드
    const camera = new Camera(videoEl, {
        onFrame: async () => {
        await pose.send({image: videoEl});
        },
    });
     {% endcomment %}
    {% comment %} camera.start(); {% endcomment %}
</script>
{% endblock %}