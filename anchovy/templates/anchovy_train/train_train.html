{% extends "base.html" %}
{% load static %}

{% block content %}
<!-- mediapipe install -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils_3d/control_utils_3d.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
<link rel="stylesheet" type="text/css" href="{% static 'test.css' %}">

    <video id="video" style="display:none" autoplay playsinline></video> 
    <div id="canvas_style">
      <h1 class="test"></h1>
      <h2 class="test2"></h2>
      <h4 class="checkstatus"></h4>
      <h4 class="score"></h4>
      <h4 class="success"></h4>
      <h4 class="score2"></h4>
      <canvas class="output_canvas"></canvas> <!--화면 크기 변경 // 화면 크기에 맞게 변경 화면이 줄어든다 (찌글어짐).-->
    </div>
    <div class="landmark-grid-container" style="display:none"></div>


{% endblock %}

{% block script %}
<script type='text/javascript'>

  var dh = window.innerHeight;
  var dw = window.innerWidth;

  const canvasElement = document.getElementsByClassName('output_canvas')[0]; // 비디오 출력을 위한 캔버스
  canvasElement.width = dw;
  canvasElement.height = dh;

    const userMedia = navigator.mediaDevices.getUserMedia({
        audio: false,
        video: {
          // 해상도 설정  // 변경 시 그에 맞게 픽셀 수 크기가 작거나 커진다
          // (크기가 커질 경우 픽셀 크기가 작아져서 화면이 작게 보이고)  // 기존에 표현하지 못했던 부분도 명확히 표현
          // (크기가 작아지는 경우 픽셀 크기가 커져서 화면이 크기 보인다) // 기존에 표현되었던 부분이 뭉게져서 표현되기 때문에 잘린것 처럼 보이게 됨
            width: 640,
            height: 360,
            facingMode: 'environment'
        }
    });
     
    userMedia.then(function (stream) {
        const videoEl = document.getElementById('video');
     
        const videoTracks = stream.getVideoTracks()[0];
        console.log('카메라 이름 : ' + videoTracks.label);
     
        videoEl.srcObject = stream;
     
    }).catch(function (error) {
        console.error(error.message);
    });


</script>

<script type="module">
    const canvasElement = document.getElementsByClassName('output_canvas')[0]; // 비디오 출력을 위한 캔버스
    const canvasCtx = canvasElement.getContext('2d'); // 2d 형태 캔버스 만들기 (그래프를 그려주는 것)
    const landmarkContainer = document.getElementsByClassName('landmark-grid-container')[0]; // 3d 좌표를 만들기 위한 container
    const grid = new LandmarkGrid(landmarkContainer);  // 3d 좌표에서 Value 값 받아오기
    

    // Canvas에 나오는 선 효과 주기
    function onResults(results) {
      
      if (!results.poseLandmarks) {
        grid.updateLandmarks([]);
        return;
      }
    
      //console.log(grid);
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.segmentationMask, 0, 0,
                          canvasElement.width, canvasElement.height);

      // Only overwrite existing pixels.
      canvasCtx.globalCompositeOperation = 'source-in';
      canvasCtx.fillStyle = 'transparent'; //transparent 투명 상태로 지정
      canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
    

      // Only overwrite missing pixels.
      canvasCtx.globalCompositeOperation = 'destination-atop';
      canvasCtx.drawImage(
          results.image, 0, 0, canvasElement.width, canvasElement.height);
    
      canvasCtx.globalCompositeOperation = 'source-over';
      drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
                     {color: '#FF0000', lineWidth: 2});
      drawLandmarks(canvasCtx, results.poseLandmarks,
                    {color: 'transparent', lineWidth: 1});
      canvasCtx.restore();
    
      // javascript에서 가져온 값을 stream 형태로 지속적으로 받아온다.
      var land = JSON.stringify(results.poseLandmarks);
    
      $.ajax({
        type: "POST",
        url: "{% url 'push_up' %}",
        data: {'landmark':land},
        dataType:'json',
        timeout : 1000, // 1초에 1번씩 데이터 넘기기
        success: function (data) {

            // 값을 업데이트
            check_stand = data.result.check_stand;
            check_status = data.result.check_status;
            score = data.result.score;
            prev = data.result.prev;
            full_count = data.result.full_count;
            excellent_count = data.result.excellent_count;

            // 테스트 문구 노출
            $(".test").empty();
            $(".test").append(check_stand);
            
            $(".test2").empty();
            $(".test2").append(results.poseLandmarks[0].y);

            $(".checkstatus").empty();
            $(".checkstatus").append(check_status);

            $(".score").empty();
            $(".score").append(full_count + '회 진행');
            console.log("총 횟수 "+ full_count)

            $(".success").empty();
            $(".success").append(excellent_count + '정확히 진행');
            console.log("정확한 횟수 "+ excellent_count)
            

        },
        error: function (data) { //데이터 받아오기 실패 (준비 시간에는 데이터를 넣지 않고 실패 형태로 진행)
          console.log('앵글 연결 실패');
        }
    });
        
    
      grid.updateLandmarks(results.poseWorldLandmarks);
    }
    
    // 모델을 가져온다
    const pose = new Pose({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
      }});

    // Pose의 옵션 값 설정
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: true,
      smoothSegmentation: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    pose.onResults(onResults);
    
    const videoEl = document.getElementById('video');
    // 카메라 실행 코드
    const camera = new Camera(videoEl, {
        onFrame: async () => {
        await pose.send({image: videoEl});
        },
    });
    
    camera.start();
</script>
{% endblock %}